# 2장 모델 주도 설계의 기본요소
혼란스러운 현실에도 불구하고 소프트웨어 구현을 건전한 상태로 유지하고 모델과의 밀접한 관계를 유지하려면 모델링과 설계의 우수 실천법을 적용해야 한다.
<br><br>
어떤 종류의 의사결정은 모델과 구현이 서로 정합된 상태를 유지해서 서로의 효과를 상호 보완하게 한다.
<br><br>
소프트웨어 시스템에서 도메인설계 외의 수많은 관심사로부터 도메인 설계를 격리하면 모델과 설계의 관계가 훨씬 분명해질 것이다. 개발 요소에 대해 이미 널리 입증된 패턴을 따른다면 구현에 실질적으로 도움이 되는 모델을 만드는 데도 도움이 될 것이다.
<br>
정교한 모델은 가장 근본적인 사항에 관심을 가질 때만 비로소 복잡성을 헤쳐나갈 수 있으며, 이는 팀에서 확신을 갖고 결합할 수 있는 상세 요소라는 결과로 나타난다.

## 04 도메인의 격리
시스템에서 도메인과 관련이 적은 기능으로부터 도메인 객체를 분리할 필요가 있으며, 그렇게 해서 도메인 개념을 다른 소프트웨어 기술에만 관련된 개념과 혼동하거나, 또는 시스템이라는 하나의 큰 덩어리 안에서 도메인을 전혀 바라보지 못하는 문제를 방지할 수 있다.

### LAYERED ARCHITECTURE (계층형 아키텍처)
객체지향 프로그램에서는 종종 사용자 인터페이스와 데이터베이스, 기타 보조적인 성격의 코드를 비즈니스 객체 안에 직접 작성하기도 한다. 이런식으로 코드를 작성하는 까닭은 단기적으로는 이렇게 하는 것이 뭔가를 동작하게 하는 가장 쉬운 방법이기 때문이다.
<br><br>
도메인에 관련된 코드가 상당한 양의 도메인과 관련이 없는 다른 코드를 통해 널리 확산될 경우 도메인에 관련된 코드를 확인하고 추론하기가 굉장히 힘들어진다.
<br><br>
매우 복잡한 작업을 처리하는 소프트웨어를 만들 경우 관심사의 분리(separation of concern)
가 필요하며 이로써 격리된 상태에 있는 각 설계 요소에 집중할 수 있다.
<br>
계층화의 핵심 원칙은 한 계층이 모든 요소는 오직 같은 계층에 존재하는 다른 요소나 계층상 "아래"에 위치한 요소에만 의존한다는 것이다. 위로 거슬러 올라가는 의사소통은 반드시 간접적인 매커니즘을 거쳐야 한다.
<br><br>
계층화의 가치는 각 계층에서 컴퓨터 프로그램의 특정 측면만을 전문적으로 다룬다는 데 있다. 이러한 전문화를 토대로 각 측면에서는 더욱 응집력 있는 설계가 가능해지며, 이로써 설계를 훨씬 더 쉽게 이해할 수 있다.

#### 성공적인 아키텍처의 개념적 계층
- 사용자 인터페이스(표현계층)
    - 사용자에게 정보를 보여주고 사용자의 명령을 해석하는 일을 책임진다. 간혹 사람이 아닌 다른 컴퓨터 시스템이 외부 행위자가 되기도 한다.

- 응용 계층
    - 소프트웨어가 수행할 작업을 정의하고 표현력 있는 도메인 객체가 문제를 해결하게 한다.
    - 이 계층에서 책임지는 작업은 업무상 중요하거나 다른 시스템의 응용 계층과 상호작용하는 데 필요한 것들이다.
    - 업무 규칙이나 지식이 포함되지 않으며, 오직 작업을 조정하고 아래에 위치한 계층에 포함된 도메인 객체의 협력자에게 작업을 위임한다.

- 도메인 계층(모델계층)
    - 업무 개념과 업무 상황에 관한 정보, 업무 규칙을 표현하는 일을 책임진다.
    - 업무 상황을 반영하는 상태를 제어하고 사용하며, 그와 같은 상태 저장과 관련된 기술적인 세부사항은 인프라스트럭처에 위임한다.

- 인프라스트럭처 계층
    - 상위 계층을 지원하는 일반화된 기술적 기능을 제공한다.
    - 애플리케이션에 대한 메시지 전송, 도메인 영속화, UI에 위젯을 그리는 것 등이 있다.


MDD를 가능케 하는 것은 결정적으로 <b>도메인 계층을</b> 분리하는 데 있다.
<br>
- 복잡한 프로그램을 여러 개의 계층으로 나눠라. 
- 응집력 있고 오직 아래에 위치한 계층에만 의존하는 각 계층에서 설계를 발전시켜라.
- 표준 아키텍처 패턴에 따라 상위 계층과의 결합을 느슨하게 유지하라.
- 도메인 모델과 관련된 코드는 모두 한 계층에 모으고 사용자 인터페이스 코드나 애플리케이션 코드, 인프라슽럭처 코드와 격리하라.


### 계층 간 관계 설정
각 계층은 설계 의존성을 오직 한 방향으로만 둬서 느슨하게 결합된다. (KT의 룰을 사용하는 이유와 비슷한 것 같다. 하위 계층에서 상위 계층을 호출하는 것은 역방향이기 때문에 룰을 통한 처리)
<br><br>
하위 수준의 객체가 상위 수준의 객체와 소통해야 할 경우에는 또 다른 메커니즘이 필요한데, 이 경우 콜백이나 옵저버 패턴 처럼 계층 간에 관계를 맺어주는 아키텍처 패턴을 활용할 수 있다.
<br><br>
분리의 주된 이점은 애플리케이션 계층이 단순해져서 애플리케이션 본연의 책임에만 집중하게 되는 것이며, 이로써 메시지를 "언제" 보내는지는 알아도 "어떻게" 보내지는지 알 필요가 없어진다. (높은 응집다, SRP)
<br><br>
응용 계층과 도메인 계층에서는 인프라스트럭처 계층에서 제공하는 SERVICE를 요청한다. SERVICE의 범위와 인터페이스를 적절히 선정하고 설계한다면 호출하는 측은 SERVICE 인터페이스에서 캡슐화하는 정교한 행위를 바탕으로 느슨하게 결합되고 단순해질 수 있다.
<br>
그러나 모든 인프라스트럭처가 상위 계층에서 호출할 수 있는 SERVICE의 형태로 만들어지는 것은 아니다.

### 아키텍처 프레임워크
가장 바람직한 아키텍처 프레임워크라면 도메인 개발자가 모델을 표현하는 것에만 집중하게 해서 복잡한 기술적 난제를 해결한다.
<br>
하지만 프레임워크가 방해가 될 수도 있는데, 프레임워크에서 도메인 설계와 관련된 의사결정을 제약하는 가정을 너무 많이 만들어 내거나 구현을 너무 과중하게 만들어 개발을 더디게 하는 경우가 있기 떄문이다.
<br><br>
프레임워크를 적용할 때 팀은 프레임워크의 목적에 집중해야 하는데, 그러한 프레임워크의 목적은 도메인 모델을 표현하고 해당 도메인 모델을 이용해 중요한 문제를 해결하는 구현을 만들어내는 데 있다.

### 도메인 계층은 모델이 살아가는 곳
도메인 주도 설계에서는 오직 한 가지 특정한 계층만이 존재할 것을 요구한다. 도메인 모델은 일련의 개념을 모아놓은 것이다. "도메인 계층"은 그러한 모델과 설계 요소에 직접적으로 관계돼 있는 모든 것들을 명시힌다.
<br><br>
도메인 로직이 프로그램상의 다른 관심사와 섞여 있다면 그와 같은 대응을 달성하기가 수월하지 않다. 따라서 도메인 주도 설계의 전제 조건은 도메인 구현을 격리하는 것이다.

#### SMART UI (지능형 UI) "안티 패턴"
- 모든 업무 로직을 사용자 인터페이스에 넣어라.
- 애플리케이션을 작은 기능으로 잘게 나누고, 나눈 기능을 각기 분리된 사용자 인터페이스로 구현해서 업무 규칙을 분리된 사용자 인터페이스에 들어가게 하라.
- 관계형 DB를 데이터의 공유 저장소로 사용하고 이용 가능한 최대한 자동화된 UI 구축 도구와 시각적인 프로그래밍 도구를 사용하라.
<br><br>
- 장점
    - 애플리케이션이 단순한 경우 생산성이 높고 효과가 즉각적으로 나타난다.
    - 다소 능력이 부족한 개발자도 약간의 교육으로 이러한 방식으로 업무를 진행할 수 있다.
    - 요구사항 분석 단계에서 결함이 발생하더라도 사용자에게 프로토타입을 배포한 후 요구에 맞게 제품을 변경해서 문제를 해결할 수 있다.
    - 애플리케이션이 서로 분리되므로 규모가 작은 모듈의 납기 일정을 비교적 정확하게 계획할 수 있다.
    - 관계형 DB 와 잘 어울리고 데이터 수준의 통합이 가능하다.

- 단점
    - 데이터베이스를 이용하는 방식말고는 여러 애플리케이션을 통합하기가 수월하지 않다.
    - 행위를 재사용하지 않으며 업무 문제에 대한 추상화가 이뤄지지 않는다.
    - 신속한 프로토타입 작성과 반복주기가 SMART UI가 지닌 태생적인 한계에 도달하게 된다. (추상화 부재로 리팩터링 제한)

Smart UI는 도메인 계층을 격리하는 데 Layered Architecture와 같은 패턴이 왜, 그리고 언제 필요한지를 분명하게 짚고 넘어가고자 살펴본 것에 불과하다.
<br><br>
아키텍처에서 응집력 있는 도메인 설계가 시스템의 다른 부분과 느슨하게 결합될 수 있게 도메인 관련 코드를 격리한다면 아마 그러한 아키텍처는 도메인 주도 설계를 지원할 수 있을 것이다.
<br><br>
<b>MDD를 하기로 했다면 고통을 감내하고 필요한 전문가를 확보하며 SMART UI를 피해야 한다.</b>

### 다른 종류의 격리
모델에 완전히 통합되지 않는 기타 도메인 구성 요소를 다뤄야 한다. 또한 같은 도메인에 대해 서로 다른 모델을 사용하는 다른 개발팀에 대처해야 할 것이다.
<br><br>
도메인을 격리할 때의 가장 좋은 점은 부수적인 것을 배제하고 도메인 설계에만 집중할 수 있다는 것이다.

## 05 소프트웨어에서 표현되는 모델
도메인 개념을 담은 객체를 정의하는 일은 겉으로는 매우 쉬워 보여도 거기에는 의미상의 미묘한 차이로 발생할 수 있는 중대한 문제가 잠재돼 있다.
<br><br>
어떤 연산의 책임을 특정 Entity 나 Value Object에서 억지로 맡기보다는 Service로 표현하는 편이 나을 때가 있다.
<br>
소프트웨어에서 수행해야 하는 것에는 해당하지만 상태를 주고받지는 않는 활동을 모델링하는 경우가 여기에 해당한다.
<br><br>
MDD에서 모듈은 모델의 한 부분이므로 도메인의 개념을 반영해야 한다.

### 연관관계
모델 내의 모든 탐색 가능한 연관관계에 대해 그것과 동일한 특성을 지닌 메커니즘이 소프트웨어에도 있다.

<b>연관관계를 좀 더 쉽게 다루는 세 가지 방법</b>
1. 탐색 방향을 부여한다. (다대다 X)
2. 한정자를 추가해서 사실상 다중성을 줄인다.
3. 중요하지 않는 연관관계를 제거한다.
<br><br>

애플리케이션 요구사항에 두 방향을 모두 탐색해야 한다는 요건이 없을 경우 탐색 방향을 추가하면 상호의존성이 줄어들고 설계가 단순해진다.

```
- 예제
국가 * --- 대통령 --> * 사람
국가 * [1790년] -- 대통령 --> 1 사람(조지워싱턴)

국가와 대통령은 다대다 관계에서 한정적인 기간이라는 조건을 추가하게 되면
관계가 다대일 관계로 매우 단순해진다.
```

### Entity (참조객체)
엔티티의 근본적인 개념은 객체의 생명주기 내내 이어지는 추상적인 연속성이며, 그러한 추상적인 연속성은 여러 형태를 거쳐 전달된다는 것이다.
<br><br>
개념적 식별성은 객체와 해당 객체의 저장 형태, 현실의 행위자의 구현 사이에서 일치해야 한다.
<br><br>
어떤 객체를 일차적으로 해당 객체의 식별성으로 정의할 경우 그 객체를 엔티티라 한다. 엔티티에는 모델링과 설계상의 특수한 고려사항이 포함돼 있다. 엔티티는 자신의 생명주기 동안 형태와 내용이 급격하게 바뀔 수도 있지만 연속성은 유지해야 한다. 또한 사실상 엔티티를 추적하려면 엔티티에 식별성이 정의돼 있어야 한다.
<br>
엔티티의 클래스 정의와 책임, 속성, 연관관계는 엔티티에 포함된 특정 속성보다는 엔티티의 정체성에 초점을 맞춰야 한다. 의미에 따라 엔티티를 분류한다면 모델이 더욱 투명해지고 구현은 견고해질 것이다.

```
식별성 예제
두 테이블이 서로 같은 식별성을 지닌 케이스

A Table
seqNo = 1357 [primary key]
createDt = 20220913

B Table
seqNo = 1357 [primary key]
createDt = 20220913
```

- 한 객체가 속성보다는 식별성으로 구분될 경우 모델 내에서 이를 해당 객체의 주된 정의로 삼아라.
- 클래스 정의를 단순하게 하고 생명주기의 연속성과 식별성에 집중하라.
- 객체의 형태나 이력에 관계없이 각 객체를 구별하는 수단을 정의하라.
- 객체의 속성으로 객체의 일치 여부를 판단하는 요구사항에 주의하라.
- 각 객체에 대해 유일한 결과를 반환하는 연산을 정의하라.
- 이 같은 식별 수단은 외부에서 가져오거나 시스템에서 자체적으로 만들어 내는 임의의 식별자일 수도 있지만, 모델에서 식별성을 구분하는 방법과 일치해야 한다.

### 엔티티 모델링
객체를 모델링할 때 속성에 관해 생각하는 것은 자연스러운 일이며, 객체의 행위에 관해 생각해보는 것은 아주 중요하다.
<br><br>
엔티티의 가장 기본적인 책임은 객체의 행위가 명확하고 예측 가능해질 수 있게 연속성을 확립하는 것이다.

### 식별 연산의 설계
각 엔티티에는 다른 객체와 구분해줄 식별성을 만들어내는 수단이 반드시 있어야 한다. 객체지향 언어에는 객체의 메모리 주소를 비교해서 두 객체 참조가 같은 것을 가리키는지 판단하는 "동일성" 연산이 포함돼 있다. 그러나 이 정도의 식별성 관리만으로는 우리의 목적을 달성하기엔 부족하다.
<br><br>
두 객체가 개념적으로 동일한 엔티티를 나타내는지 어떻게 알 수 있는가? 식별성에 대한 정의는 모델로부터 나온다. 따라서 식별성을 정의하려면 도메인을 이해해야 한다.

### Value Object (값 객체)
엔티티의 식별성을 관리하는 일은 매우 중요하지만 그 밖의 객체에 식별성을 추가한다면 시스템의 성능이 저하되고, 분석 작업이 별도로 필요하며, 모든 객체를 동일한 것으로 보이게 해서 모델이 혼란스러워질 수 있다.
<br><br>
객체를 단순히 식별성이 없는 것으로만 생각한다면 우리의 도구상자나 어휘에 추가할 게 그리 많지 않을 것이다. 사실 이 같은 객체는 자체적인 특징을 비롯해 모델에 중요한 의미를 지닌다. 이것들이 바로 사물을 서술하는 객체다.
<br><br>
<b>개념적 식별성을 갖지 않으면서 도메인의 서술적 측면을 나타내는 객체를 Value Object라 한다.</b>
<br><br>
- 모델에 포함된 어떤 요소의 속성에만 관심이 있다면 그것을 Value Object로 분류하라.
- Value Object에서 해당 Value Object가 전하는 속성의 의미를 표현하게 하고 관련 기능을 부여하라.
- Value Object는 불변적으로 다뤄라.
- Value Object에는 아무런 식별성도 부여하지 말고 엔티티를 유지하는 데 필요한 설계상의 복잡성을 피하라.

#### Value Object의 설계
Value Object는 많아지는 경향이 있으므로 성능 최적화를 위한 별도의 대안을 마련하는 것이 중요할 수 있다. 
<br>
각 전기 콘센트가 개별 Value Object라면 하나의 주택 도면에도 수백 개의 Value Object가 있을지도 모른다. 그러나 콘센트를 모두 상호교환 가능한 것으로 간주한다면 단순히 한 콘센트 인스턴스를 공유해서 해당 인스턴스를 수백 번에 걸쳐 같은 것을 가리키게 할 수도 있다. (FlyWeight 예제)
<br>
이것은 엔티티에는 적용할 수 없는 최적화 기법의 한 가지 사례에 불과하다.
<br><br>
복사와 공유 중 어느 것이 경제성 면에서 더 나은지는 구현 환경에 따라 달라진다.
공유는 다음과 같은 경우 가장 도움이 되고 문제가 적게 일어나며, 이러한 경우로 공유를 제한한다.

- 공간이 절약하거나 데이터베이스 내의 객체 수를 줄이는 것이 중요한 경우
- 통신 부하가 낮은 경우 (이를테면, 중앙집중형 서버)
- 공유 객체의 불변성이 엄격하게 지켜지는 경우

Value Object가 불변적인 한 변경관리는 단순해진다. 즉, 완전히 교체하지 않는 한 아무것도 변경되지 않는다. 불변 객체는 전기 콘센트 예처럼 마음껏 공유할 수 있다.

##### 변경가능성을 허용하는 경우
- Value가 자주 변경되는 경우
- 객체 생성이나 삭제에 비용이 많이 드는 경우
- 교체(변경이 아닌)로 인해 클러스터링이 제한되는 경우
- Value를 공유할 일이 그리 많지 않거나 클러스터링을 향상시키기 위해서나 다른 기술적인 이유로 공유가 보류된 경우

#### Value Object를 포함한 연관관계 설계
엔티티 간의 양방향 연관관계는 유지하기는 어려울 수 있는 반면 두 Value Object 간의 양방향 연관관계는 단순히 논리적으로 타당하지 않다.
<br>
어떤 객체를 식별성 없이 자신을 가리키는 동일한 Value Object를 역으로 가리키는 것은 아무런 의미가 없다.
<br><br>
엔티티와 VO가 관례적인 객체 모델의 주된 요소이긴 하지만 실용주의 설계자들은 한 가지 또 다른 요소인 서비스를 사용해 오고 있다.

### Service(서비스)
설계가 매우 명확하고 실용적이더라도 개념적으로 어떠한 객체에도 속하지 않는 연산이 포함될 때가 있다. 이러한 문제를 해결하기보단 문제 자체의 면면에 따라 서비스를 모델에 명시적으로 포함할 수 있다.
<br><br>
엔티티나 VO에서 찾지 못하는 중요한 도메인 연산이 있다. 일부는 사물이 아닌 활동이나 행동인데 이러한 연산도 객체와 잘 어울리게끔 노력해야 한다.
<br><br>
서비스는 특정 연산을 수행하는 것 이상의 의미는 없는 모델 객체로 가장해서 나타나기도 한다. 이 같은 행위자는 뒤에 Manager와 같은 것이 붙는다. 이런 행위자 객체는 도메인에서 맡고 있는 연산 이상으로는 어떠한 의미도 갖지 않는다.
<br><br>
서비스는 엔티티나 VO와 달리 상태를 캡슐화하지 않는다.
<br>
서비스를 정의하는 기준은 순전히 클라이언트에 무엇을 제공할 수 있느냐에 있다.
<br>
서비스는 적절히 사용해야 하고 엔티티와 VO의 행위를 모두 가져와서는 안된다.

#### 잘 만들어진 서비스의 세 가지 특징
1. 연산이 원래부터 엔티티나 VO의 일부를 구성하는 것이 아니라 도메인 개념과 관련돼 있다.
2. 인터페이스가 도메인 모델의 외적 요소의 측면에서 정의된다.
3. 연산이 상태를 갖지 않는다.
    - 자신의 행위에 영향을 줄 수 있는 상태를 갖지 않는다.

```
- 도메인의 중대한 프로세스나 변환 과정이 엔티티나 VO의 고유한 책임이 아니라면 연산을 서비스로 선언되는 독립 인터페이스로 모델에 추가하라.
- 모델의 언어라는 측면에서 인터페이스를 정의하고 연산의 이름에 보편언어의 일부가 되게끔 구성하라.
- 서비스는 상태를 갖지 않게 만들어라.
```

#### 서비스와 격리된 도메인 계층
도메인 계층에 속하는 서비스와 다른 계층에 속하는 것들을 구분하고, 그러한 구분을 분명하게 유지하는 책임을 나누는 데 주의를 기울여야 한다.

```
- 예시 [ 인프라스트럭처 서비스 ]
도메인 서비스와 응용 서비스는 인프라스트럭처 서비스와 협업하는데, 예로 은행에서 잔고가 일정금액 이하로 떨어지면 고객에게 이메일을 발송하는 애플리케이션이 있다고 가정해보자. 이 때 이메일 시스템과 통지 수단을 캡슐화 하는 인터페이스는 인프라스트럭처 계층의 서비스에 해당한다.

- 예시 [ 서비스(응용) 과 서비스(도메인) 분리 ]
[도메인 서비스]
한 계좌에서 다른 계좌로 자금을 이체하는 기능은 도메인 서비스에 해당한다. 자금 이체 기능에는 중요한 업무 규칙이 포함돼 있고, "자금 이체"는 중요한 은행업무 도메인의 용어이기 때문이다.

[응용 서비스]
뱅킹 애플리케이션에서 거래를 분석할 수 있게 스프레드시트 파일로 거래 내역을 변환해 내보낼 수 있는 기능은 응용 서비스에 해당한다. 은행 업무 도메인에서 "파일형식" 이라는 것은 아무런 의미가 없으며, 그것과 관련된 어떠한 업무 규칙도 없기 떄문이다.

```
수많은 도메인 서비스나 응용 서비스는 엔티티나 VO를 토대로 만들어져 도메인의 잠재 기능을 조직화함으로써 실제 뭔가가 이뤄지게 하는 시나리오 같다. 간혹 엔티티나 VO를 너무 디테일하게 구성하여 도메인 계층의 기능을 편리하게 사용할 수 없게 되기도 한다.
<br><br>

<b> - 서비스를 여러 계층으로 분할하기</b>
<table border="1">
    <tr>
        <th>응용</th>
        <td>
            <b>자금 이체 응용 서비스</b>
            <br> - 입력(XML 요청과 같은) 내용의 암호화
            <br> - 이체 처리를 위한 도메인 서비스로의 메시지 전송
            <br> - 이체 확인 대기
            <br> - 인프라스트럭처 서비스를 이용한 통지 결정
        </td>
    </tr>
<tr>
    <th>도메인</th>
    <td>
        <b>자금 이체 도메인 서비스</b>
        <br> - 금액 인출/입금에 필요한 Account(계좌)와 Ledger(원장) 객체 간의 상호작용
        <br> - 이체 결과 확인 정보 제공(이체 수락 여부 등)
    </td>
</tr>
<tr>
    <th>인프라스트럭처</th>
    <td>
        <b>통지 서비스</b>
        <br> - 애플리케이션에서 지정한 곳으로 이메일이나 우편 등을 보냄
    </td>
</tr>
</table>

#### 구성 단위