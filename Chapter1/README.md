# 1장 동작하는 도메인 만들기

모든 소프트웨어 프로그램은 그 소프트웨어를 사용하는 사용자의 활동이나 관심사와 관련되어 있다.<br>사용자가 프로그램을 사용하는 대상 영역이 바로 해당 소프트웨어의 도메인이다.<br>
모델이란 지식을 선택적으로 단순화하고 의식적으로 구조화한 형태다. 우리는 적절한 모델을 토대로 정보를 이해하고 문제 자체에 집중할 수 있다.<br>
도메인 모델은 어떤 특정한 다이어그램이 아니라 다이어그램이 전달하고자 하는 아이디어다.<br>
도메인 모델링은 어떤 목적에 따라 제약에 구애받지 않고 현실을 표현하는 영화 제작에 더 가깝다.

## 도메인 주도 설계에서의 모델의 유용성
1. 모델과 핵심 설계는 서로 영향을 주며 구체화된다.
    - 모델을 의미있게 만들고 모델의 분석이 최종 산출물인 동작하는 프로그램에 적용되게끔 보장하는 것은 다름이 아닌 모델과 구현 간의 긴밀한 연결이다.
2. 모델은 모든 팀 구성원이 사용하는 언어의 중추다.
    - 모델과 구현이 연결되어 있으므로 개발자와 도메인 전문가가 의사소통하는데 별도의 변역 절차기 필요없다.
3. 모델은 지식의 정수만을 뽑아낸 것이다.
    - 모델은 도메인 지식을 조직화하고 가장 중요한 요소를 구분하는 팀의 합의된 방식이다.

## 소프트웨어의 본질
소프트웨어의 본질은 소프트웨어의 사용자를 위해 도메인에 관련된 문제를 해결하는 능력에 있다.<br>
팀의 리더가 도메인의 중심이 되는 개념을 알고 있어야 해당 도메인의 심층적인 이해를 반영하는 모델 개발이 모르는 사이에 갈피를 잡지 못할 때 소프트웨어 프로젝트를 올바른 방향으로 되돌려 놓을 수 있다.

## 01 지식 탐구

### 효과적인 모델링의 요소
1. 모델과 구현의 연계
    - 초기 프로토타입을 토대로 본질적인 연결 고리를 만든 다음, 이어지는 모든 반복 주기 내내 그 연결 고리를 유지했다.
2. 모델을 기반으로 하는 언어 정제
    - 서로 다른 지식의 용어를 설명한 후 이후 커뮤니케이션에선 별도의 해석 없이 의미를 명확하게 이해한다.
3. 풍부한 지식이 담긴 모델 개발
    - 객체는 행위를 지니고 규칙을 이행했다. 모델은 단순히 데이터 스키마가 아닌 복잡한 문제를 해결하는 데 필수불가결한 것이었다.
4. 모델의 정제
    - 모델이 점차 완전해지면서 중요한 개념이 더해졌으며, 마찬가지로 쓸모없거나 중요하지 않다고 판명된 개념이 제거됐다는 점 또한 중요하다.
5. 브레인스토밍과 실험

### 지식 탐구
효과적으로 도메인 모델링을 수행하는 사람들도 지식을 면밀히 탐구한다. 그들은 전체를 이해할 수 있는 간결한 관점을 찾아 체계적인 아이디어들을 차례로 시도해본다. 그 과정에서 수많은 모델이 시도, 거부, 변형된다.<br>
지식 탐구는 혼자서 하는 활동이 아니다. 개발자와 도메인 전문가로 구성된 팀은 대체로 개발자가 이끄는 가운데 협업한다.<br>
프로그래머가 리팩터링을 하면서 개발한다면 소프트웨어는 계속 확장이 가능한 말끔한 상태로 <b>유지되겠지만 프로그래머가 도메인에 관심이 없다면 그 이면에 숨겨진 원리는 알지 못한 채 애플리케이션에서 수행해야 할 사항만 습득한다.</b>

### 지속적인 학습
생산성이 매우 뛰어난 팀은 지속적인 학습을 바탕으로 의식적으로 지식을 함양한다.

### 풍부한 지식이 담긴 설계
모델에 포착돼 있는 지식은 단순한 "명사 찾기" 이상이다. 도메인에 관련된 엔티티만큼 업무 활동과 규칙도 도메인에 중요한데, 어떠한 도메인에도 다양한 범주의 개념이 존재한다.

설계를 디테일한 수준까지 올리고, 메서드의 명칭을 의미있게 작성하려면 단순 요구사항이 아닌 도메인지식을 알고 어떤 업무인지 파악하고 있어야 한다.
``` java
// 도메인 지식을 모르고 기능만 구현했을 때
if ((cargo.size() + voyage.bookedCargoSize()) >= (voyage.capacity() * 1.1)) {
    return -1;
}

// 도메인지식을 알고 있을 떄
// 개발자가 아니라도 의미파악이 훨씬 수월하다.
if (!overbookingPolicy.isAllowed(carge, voyage)) return -1;

public boolean isAllowed (Carge carge, Voyage voyage) {
    return (cargo.size() + voyage.bookedCargoSize()) <= (voyage.capacity() * 1.1);
}
```

## 02 의사소통과 언어 사용
도메인 모델은 소프트웨어 프로젝트를 위한 공통 언어의 핵심이 될 수 있다.<br>
모델은 프로젝트에 참여한 사람들의 머릿속에 축적된 개념을 모아 놓은 것으로서 도메인에 대한 통찰력을 반영하는 용어와 관계로 표현된다.

### UBIQUITOUS LANGUAGE (보편언어)
유연하고 풍부한 지식이 담긴 설계를 만들려면 다용도로 사용할 수 있는 팀의 공유 언어와 그 언어에 대한 활발한 실험이 필요하다. 하지만 아쉽게도 소프트웨어 프로젝트에서는 그와 같은 실험이 거의 일어나지 않는다.

공통 언어가 없는 프로젝트에서는 개발자가 도메인 전문가를 위해 자신들의 언어를 번역해줘야 한다. 반대의 경우도 마찬가지이다. 모델의 개념을 혼란스럽게 만드는 번역은 해로운 코드 리팩터링으로 이어진다. 번역에 따르는 노력으로 심층 모델에 대한 통찰력에 이르게 하는 지식과 아이디어의 상호 작용이 저해된다.
<br><br>
모델의 관계는 모든 언어에 내재된 결합 규칙이 된다. 단어와 구절의 의미는 모델을 구성하는 개별 요소의 의미를 각각 반영한다.<br>
모델은 개발자와 도메인 전문가가 서로 의사소통하는 것뿐만 아니라 도메인 전문가들이 서로 요구사항, 개발 계획, 기능에 관해 의사소통하는 데도 언어를 제공해야 한다.<br><br>
모델을 언어의 근간으로 사용하라. 팀 내 모든 의사소통과 코드에서 해당 언어를 끊임없이 적용하는 데 전념하라. 다이어그램과 문서에서, 그리고 특히 말할 때 동일한 언어를 사용하라.<br><br>
도메인 전문가는 도메인을 이해하는 데 부자연스럽고 부정확한 용어나 구조에 대해 반대 의사를 표명해야 하며, 개발자는 설계를 어렵게 만드는 모호함과 불일치를 찾아내는 데 촉각을 곤두 세워야 한다.

#### 크게 소리내어 모델링하기
다이어그램을 그려서 시각적/공간적 추론 능력을 활용하는 것이 중요한 것과 마찬가지로 모델링할 때 우리의 언어 능력을 활용해 단어와 구절을 곱씹어보는 것도 절대적으로 필요하다.<br><br>
<b>시스템에 관해 이야기를 주고받을 때 모델을 사용하라. 모델의 요소와 상호작용을 이용하고 모델이 허용하는 범위에 개념을 조합하면서 시나리오를 큰 소리로 말해보라. 표현해야 할 것을 더 쉽게 말하는 방법을 찾아낸 다음 그러한 새로운 아이디어를 다이어그램과 코드에 적용하라.</b>

#### 문서와 다이어그램
문제는 사람들이 UML을 통해서만 전체 모델이나 설계를 전달해야 한다고 느낄 떄 생긴다. 많은 객체 모델 다이어그램은 지나치게 오나전한 동시에 많은 부분이 생략돼 있다.<br>
속성과 관계는 객체 모델의 반 정도를 차지할 뿐이다. 객체의 행위와 제약조건은 그리기가 수월하지 않다. 객체 상호작용 다이어그램은 설계상 몇 가지 다루기 어려운 부분을 설명할 수도 있지만 상호작용의 상당수는 그러한 방식으로 표현할 수 없다.<br><br>
UML다이어그램은 모델의 가장 중요한 두 가지 측면을 전달할 수 없는데, 그것은 바로 모델이 나타내는 개념의 의미와 모델 내 객체의 행위다.<br>
다이어그램은 의사소통과 설명의 수단이며 브레인스토밍을 촉진한다. 이러한 목적은 다이어그램이 최소화됐을 때 가장 잘 달성된다.<br>
모델은 다이어그램이 아니라는 점을 항상 명심해야 한다. 다이어그램의 목적은 모델을 전달하고 설명하는 데 있다.

#### 글로 쓴 설계문서
문서가 일단 어떤 변하지 않는 형태를 취하게 되면, 종종 프로젝트의 흐름과 연관성을 끊어버리곤 한다. 즉, 문서가 프로젝트나 코드의 발전에 뒤쳐지게 되는 것이다.

- 문서는 코드와 말을 보안하는 역할을 해야 한다.
    - 각 애자일 프로세스에는 문서에 관한 나름의 철학이 있다. 익스트림 프로그래밍에는 여분의 설계문서를 전혀 사용하지 않고 코드 스스로 별도의 설명이 필요없는 상태를 유지해야 한다.

- 문서는 코드가 이미 잘 하고 있는 것을 하려고 해서는 안 된다.
    - 코드는 코드 자체로 세부사항을 충족한다.
    - 다른 문서들은 의미를 설명하고 대규모 구조에 통찰력을 주며, 핵심 요소에 집중할 필요가 있다.

- 문서의 현행화
    - 문서는 항상 최신 정보를 담고 있어야 한다.

설계 문서에 가장 큰 가치는 모델의 개념을 설명하고, 코드의 세부사항을 파악하는 데 도움을 주며, 어쩌면 모델의 의도된 방식에 어떤 통찰력을 주는 데 있다.

#### 설명을 위한 모델
하나의 모델이 구현, 설계, 의사소통의 기초가 되어야 한다는 것이다. 모델은 도메인을 가르치는 도구로서 아주 유용할 수 있다.
<br> 설명을 위한 모델에서는 특정 주제에 맞춰 훨씬 더 전달력이 높은 의사소통 방식을 마음껏 만들어 낼 수 있다.<br>
설명을 위한 모델은 꼭 객체일 필요가 없으며, 오히려 객체가 아닐 때가 일반적으로 가장 좋다.<br>
실제로 이런 상황에서는 UML을 지양하고 UML과 소프트웨어 설계와의 관련성에 관해 잘못된 인상을 주지 않는 것이 좋다. 심지어 설명을 위한 모델과 설계를 위한 모델이 상응하는 경우가 있더라도, 비슷하다는 것이 정확함을 담보하는 경우는 거의 없다. 혼동을 피하려면 모든 이가 이 둘의 차이를 의식하고 있어야 한다.

## 03 모델과 구현의 연계

### 모델 주도 설계 (Model - Driven - Design)
도메인 모델은 전혀 없고 기능만 차례로 구현하기 위해 코드만 작성하는 프로젝트에서는 지식 탐구와 의사소통의 이점을 거의 살리지 못한다. 도메인이 복잡하다면 이러한 프로젝트는 난관에 처할 것이다.<br><br>
모델과 코드 간의 연결이 끊어지는 경우는 다양하고 종종 의도적으로 그렇게 할 때도 있다. 여러 설계 방법론에서는 분석모델의 필요성을 지지하는데 분석모델은 설계와 뚜렷이 구분되고, 보통 다른 사람이 만든다. 이를 분석모델이라고 하는 이유는 분석 모델이 소프트웨어 수행할 역할에 대해서는 전혀 고려하지 않은 채 업무 도메인의 개념만을 체계화 하고자 해당 업무 도메인을 분석한 결과물이기 떄문이다.
<br><br>
설계 혹은 설계의 주된 부분이 도메인모델과 대응하지 않는다면 그 모델은 그다지 가치가 없으며 소프트웨어의 정교함도 의심스러워진다. 동시에 모델과 설계 기능 사이의 복잡한 대응은 이해하기 힘들고, 실제로 설계가 변경되면 유지보수가 불가능해진다. 분석과 설계가 치명적으로 동떨어지고, 그에 따라 각자의 통찰력에서 얻은 통찰력이 서로에게 전해지지 않는다.
<br><br>
MDD(Model - driven - design) 에서는 양쪽 모두의 목적을 달성하는 단일 모델을 찾기 위해 분석모델과 설계를 나누는 이분법은 채택하지 않는다.
<br><br>
도메인 모델을 설계에 밀접하게 연관시키는 원칙을 강제하면 가능한 각종 모델 가운데 유용한 것을 선택하는 또 하나의 기준이 만들어진다. 많은 고민과 수차례 걸친 반복주기와 리팩터링이 필요하겠지만, 관련성 있는 모델이 만들어진다.

#### 모델링 패러다임과 도구 지원
객체지향 언어처럼 많은 사람들이 쓰진 않지만 프롤로그(Prolog)라는 언어는 MDD에 잘 어울린다.
C같은 언어를 사용할 때는 MDD를 적용하기가 어려운데, 이는 순수하게 절차적인 언어에 대응되는 모델링 패러다임은 없기 때문이다.

#### 내부 드러내기: 왜 모델이 사용자에게 중요한가
실제로 사용자가 바라보는 것과 시스템이 불일치한다면 혼란을 일으킬 수도 있고, 최악의 경우에는 버그를 유발할 수 있다.<br>
MDD에서는 오로지 하나의 모델을 다룰 것을 요구한다.<br><br>
도메인 모델을 있는 그대로 바라노는 것은 확실히 대부분의 경우 사용자에게 편리하지 않을 것이다. 그러나 UI에 도메인 모델이 아닌 다른 모델의 환영을 만들려는 시도는 그것이 완벽하지 않을 경우 혼란만 초래한다.

### HANDS-ON MODELER(실천적 모델러)
제조업은 소프트웨어 개발 분야에서 인기 있는 은유(metaphor)다. 이 은유로부터 한 가지 추론할 수 있는 점은 고도로 숙련된 엔지니어는 설계를, 덜 숙련된 노동자는 제품을 조립한다.
<br>
모든 팀원에게는 각기 전문화된 역할이 있지만 분석과 모델링, 설계, 프로그래밍에 대한 책임을 지나치게 구분하는 것은 MDD와 상충한다.
<br><br>
코드를 작성하는 사람이 모델에 책임을 느끼지 못하거나 애플리케이션을 대상으로 모델이 동작하게 만드는 법을 모른다면 그 모델은 소프트웨어와 무관해진다. 코드의 변경이 곧 모델의 변경이라는 점을 개발자가 인식하지 못하면 리팩터링은 모델을 강화하기보다는 약화시킬 것이다.
<br><br>
모델이 효과적인 구현을 뒷받침하고 핵심 도메인 지식을 추상화한다는 MDD의 기본적인 제약조건은 절반쯤 사라지고, 결과로 나타나는 모델은 실용적이지 못할 것이다.
